/* @flow */

import fs from 'fs';
import path from 'path';
import yaml from 'js-yaml';
import Workflow from './workflow';
import Job from './job';
import Branches from './branches';
import executors from './executors';

export { Workflow, Job, Branches, executors };

const arrayToObject = a => a.reduce((acc, curr) => ({ ...acc, ...curr }), {});

export default class Config {
  static CONFIG_LOCATION = '.circleci/config.yml';
  place: string = path.resolve(Config.CONFIG_LOCATION);
  workflows: Array<Workflow> = [];

  clone() {
    const item = new this.constructor();
    item.place = this.place;
    item.workflows = [...this.workflows];

    return item;
  }

  workflow(workflow: Workflow) {
    const item = this.clone();
    item.workflows.push(workflow);

    return item;
  }

  location(directory: string = __dirname) {
    const item = this.clone();
    item.place = path.resolve(directory, item.constructor.CONFIG_LOCATION);

    return item;
  }

  compose() {
    const workflows = this.workflows
      .map(w => w.compose())
      .reduce((acc, curr) => ({ ...acc, ...curr }), {});
    const jobs = this.workflows
      .map(w =>
        arrayToObject(
          w.jobs.filter(j => j.type !== 'approval').map(j => j.job.compose()),
        ),
      )
      .reduce((acc, curr) => ({ ...acc, ...curr }), {});
    return {
      version: 2,
      workflows: {
        version: 2,
        ...workflows,
      },
      jobs,
    };
  }

  dump() {
    const config = this.compose();

    return yaml.safeDump(config);
  }

  toWrite(show: boolean) {
    const dump = this.dump();
    // prettier-ignore
    const disclaimer =
`# CAUTION! This file is automatically generated by \`circle-config-creator\`.
# You should edit the source used to generate this config, or your changes will
# be overwritten the next time the source is changed.

${dump}`;
    if (show) {
      return disclaimer;
    }

    return dump;
  }

  write(disclaimer: boolean = true, cb: ?(?ErrnoError) => mixed) {
    const toWrite = this.toWrite(disclaimer);

    const p = path.resolve(this.place);
    return new Promise((resolve, reject) => {
      fs.writeFile(p, toWrite, err => {
        if (cb) {
          cb(err);
        }
        if (err) {
          reject(err);
        } else {
          resolve();
        }
      });
    });
  }

  writeSync(disclaimer: boolean = true) {
    const toWrite = this.toWrite(disclaimer);

    const p = path.resolve(this.place);
    fs.writeFileSync(p, toWrite);
  }
}
